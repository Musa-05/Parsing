"""расшифровать путь посредством маршрутного шифра союзников.
О Предназначено для полнословных перестановочных шифров с
переменными строками и столбцами. Исходит из допущения, что
шифрование началось вверху или внизу столбца.
Ключ указывает на порядок чтения столбцов и направление прохождения.
Отрицательные числа столбцов означают начало снизу и чтение вверх.
Положительные числа столбцов означают начало сверху и чтение вниз.
Приведенный ниже пример предназначен для матрицы 4x4 с ключом -12-34.
Примечание: "0" не допускается.
Стрелки показывают маршрут шифрования; для отрицательных значений ключа
читать ВВЕРХ.
 1   2   3   4
 ___ ___ ___ ___
| ^ | | | ^ | | | СООБЩЕНИЕ ПИШЕТСЯ

|_|_|_v_|_|_|_v_|
| ^ | | | ^ | | |ПОПЕРЕК КАЖДОЙ СТРОКИ

|_|_|_v_|_|_|_v_|
| ^ | | | ^ | | | ТАКИМ ОБРАЗОМ

|_|_|_v_|_|_|_v_|
| ^ | | | ^ | | | ПОСЛЕДНЯЯ СТРОКА ЗАПОЛНЯЕТСЯ ФИКТИВНЫМИ СЛОВАМИ

|_|_|_v_|_|_|_v_|
НАЧАЛО          КОНЕЦ

Необходимые входные данные - текстовое сообщение, число столбцов,
число строк, символьная цепочка с ключом
Печатает переведенный текст"""

import sys

# ================================================================
# ВХОДНЫЕ ДАННЫЕ ПОЛЬЗОВАТЕЛЯ:
# дешифруемая символьная цепочка (введите или вставьте между тройными кавычками) :

ciphertext = """16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19"""

# число столбцов в перестановочной матрице:
COLS = 4

# число строк в перестановочной матрице:
ROWS = 5

# ключ с пробелами между числами; отрицательный
# для чтения ВВЕРХ столбц (например, -1 2 -3 4) :

key = """-1, 2 -3, 4"""


# КОНЕЦ ВХОДНЫХ ДАННЫХ ПОЛЬЗОВАТЕЛЯ - НЕ РЕДАКТИРОВАТЬ НИЖЕ
# ЭТОЙ СТРОКИ!
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


def main():
    """Выполнить программу и напечатать расшифрованный открытый текст."""
    print(f'Шифротекст =  {ciphertext}')
    print(f'Тестирование столбцов {COLS}')
    print(f'Тестирование строк {ROWS}')
    print(f'Тестирование ключей {key}')

    # разбить элементы на слова, не на бу
    cipherlist = list(ciphertext.split())
    validate_col_row(cipherlist)
    key_int = key_to_int(key)
    translation_matrix = build_matrix(key_int, cipherlist)
    plaintext = decrypt(translation_matrix)

    print(f'Открытый текст = {plaintext}')


def validate_col_row(cipherlist):
    """Проверить, что входные столбцы и строки приемлемы
    по отношению к длине сообщения."""
    factors = []
    len_cipher = len(cipherlist)
    for i in range(2, len_cipher):  # диапазон исключает 1 столбец шифров
        if len_cipher % i == 0:
            factors.append(i)
    print(f'Длина шифра = {len_cipher}')
    print(f'Приемлемые значения столбцов/строк включают: {factors}')
    print()
    if ROWS * COLS != len_cipher:
        print(f'Ошибка - входные столбцы и строки не являются кратными длины шифра. Завершение программы.',
              file=sys.stderr)
        sys.exit(1)


def key_to_int(key):
    """Превратить ключ в список целых чисел и проверить допустимость."""
    key_int = [int(i) for i in key.split()]
    key_int_lo = min(key_int)
    key_int_hi = max(key_int)
    if len(key_int) != COLS or key_int_lo < -COLS or key_int_hi > COLS or 0 in key_int:
        print(f'Ошибка - проблема с ключом. Завершение.', file=sys.stderr)
        sys.exit(1)
    else:
        return key_int


def build_matrix(key_int, cipherlist):
    """Превратить каждые п элементов в списке в новый элемент
    в списке списков."""
    translation_matrix = [None] * COLS
    start = 0
    stop = ROWS
    for k in key_int:
        if k < 0:  # читать в столбце снизу-вверх
            col_items = cipherlist[start:stop]
        elif k > 0:  # читать в столбце сверху-вних
            col_items = list((reversed(cipherlist[start:stop])))
        translation_matrix[abs(k) - 1] = col_items
        start += ROWS
        stop += ROWS
    return translation_matrix


def decrypt(translation_matrix):
    """Перебрать вложенные списки в цикле, выталкивая последний элемент
    в символьную цепочку."""
    plaintext = ''
    for i in range(ROWS):
        for matrix_col in translation_matrix:
            word = str(matrix_col.pop())
            plaintext += word + ' '
    return plaintext


if __name__ == '__main__':
    main()
